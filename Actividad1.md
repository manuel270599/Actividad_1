¿Por qué surgió la necesidad de DevOps en el desarrollo de software?/
La necesidad surge al tener un escenario conflictivo por parte de los desarrolladores con el equipo de desarrollo, existiendo un "silo" una carencia de integración o comunicación por parte de ambas areas de trabajo generando ineficiencias en el desarrollo de software.

Explica cómo la falta de comunicación y coordinación entre los equipos de desarrollo y operaciones en el pasado ha llevado a la creación de DevOps./
Al haber una barrera entre estas areas hay un mal manejo de informacion por ende resulta catastrofico unificar partes que no fueron creadas bajo una misma idea, ¿pero que pasa si esta barrera se rompe o desintegra? es claro un mejor rendimiento y resultados optimos, acelerando el flujo de trabajo y llegar al propósito requerido.

Describe cómo el principio de mejora continua afecta tanto a los aspectos técnicos como culturales de una organización./
El principio de mejora continua es la base de DevOps ofreciendo ventajas técnicas o culturales en el desarrollo de software moderno, un pusto de vista técnico, confiabilidad, adaptabilidad y eficiencia en los procesos de entrega. Todo esto fomenta un entorno colaborativo alentando a una cultura de aprendizaje.

¿Qué significa que DevOps no se trata solo de herramientas, individuos o procesos?/
Que independiende de la herramienta, persona o proceso a realizar con la "etiqueta" de DevOps en tu proyecto no significa que hayas logrado DevOps, no es algo puntual o utilizable.

Según el texto, ¿cómo contribuyen los equipos autónomos y multifuncionales a una implementación exitosa de DevOps?/
Su contribución se da con la disolución de barreras para agilizar el flujo de trabajo.

Parte 1:
Inicializacion del proyecto.

![Inicializacion del proyecto](./Actividad1_images/Parte1.PNG)

le damos la estructura al proyecto.
![le damos la estructura al proyecto](./Actividad1_images/Parte2.PNG)

Editamos el archivo app.js.

![Editamos el archivo app.js](./Actividad1_images/Parte3.PNG)

app.test.js

![app.test.js](./Actividad1_images/Parte4.PNG)

Editamos el archivo app.test.js

![Editamos el archivo app.test.js](./Actividad1_images/Parte5.PNG)

Navegamos al archivo .json

![navegamos al archivo .json](./Actividad1_images/Parte6.PNG)

Editamos el archivo package.json

![Editamos el archivo package.json](./Actividad1_images/Parte7.PNG)

Configuramos integración continua (CI) con GitHub Actions

![ Configuramos integración continua (CI) con GitHub Actions](./Actividad1_images/Parte8.PNG)

Editamos el archivo ci.yml

![Editamos el archivo ci.yml](./Actividad1_images/Parte9.PNG)

Iniciamos git

![Iniciamos git](./Actividad1_images/Parte10.PNG)

Subimos el codigo a github

![Subimos el codigo a github](./Actividad1_images/Parte11.PNG)


Parte 2: Configura entrega continua (CD) con Docker

Creamos el archivo Dockerfile.

![Dockerfile](./Actividad1_images/Parte12.PNG)

Construimos la imagen Docker

![imagen Docker](./Actividad1_images/Parte13.PNG)

![imagen Docker](./Actividad1_images/Parte14.PNG)

Corremos el contenedor localmente

![imagen Docker](./Actividad1_images/Parte15.PNG)

Verificamos el " hello world"

![helloworld](./Actividad1_images/Parte16.PNG)

Parte 3: Automatización con Docker Compose
Para facilitar la gestión de tu entorno, puedes usar Docker Compose.
Crea un archivo docker-compose.yml:

![dockercompose](./Actividad1_images/Parte19.PNG)

Corre la aplicación usando Docker Compose:

![dockercompose](./Actividad1_images/Parte17.PNG)

hello world

![dockercompose](./Actividad1_images/Parte18.PNG)

confirmamos la accion del contenedor 

![dockercompose](./Actividad1_images/Parte20.PNG)

















